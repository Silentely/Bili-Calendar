// main.js
import express from 'express';
import path from 'path';
import fs from 'fs';
import crypto from 'crypto';
import { createRequire } from 'module';
import { fileURLToPath } from 'url';
const require = createRequire(import.meta.url);
const { getBangumiData } = require('./utils/bangumi.cjs');

// Â§çÁî®ICSÂ∑•ÂÖ∑Ôºà‰ΩøÁî® CJS ÁâàÊú¨Ôºâ
const { generateICS, respondWithICS, respondWithEmptyCalendar } = require('./utils/ics.cjs');

const app = express();

const PORT = process.env.PORT || 3000;
const CORS_HEADERS = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Methods': 'GET, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type',
};

// ÂàõÂª∫ÁÆÄÂçïÁöÑÂÜÖÂ≠òÂ≠òÂÇ®ÈôêÊµÅÂô®
const rateLimiter = {
  // Â≠òÂÇ®ÁªìÊûÑ { ip: { count: 0, resetTime: timestamp } }
  store: {},

  // ÁéØÂ¢ÉÂèòÈáèÊéßÂà∂ÈôêÂà∂
  MAX_REQUESTS: process.env.API_RATE_LIMIT || 3, // ÈªòËÆ§ÊØèÂ∞èÊó∂3Ê¨°
  TIME_WINDOW: process.env.API_RATE_WINDOW || 60 * 60 * 1000, // ÈªòËÆ§1Â∞èÊó∂(ÊØ´Áßí)
  ENABLED: process.env.ENABLE_RATE_LIMIT !== 'false', // ÈªòËÆ§ÂêØÁî®

  // Ê£ÄÊü•Âπ∂ÈÄíÂ¢ûËÆ°Êï∞
  check(ip) {
    const now = Date.now();

    // Â¶ÇÊûúÂäüËÉΩË¢´Á¶ÅÁî®ÔºåÂßãÁªàÂÖÅËÆ∏ËØ∑Ê±Ç
    if (!this.ENABLED) return true;

    // ÂàùÂßãÂåñÊàñÈáçÁΩÆËøáÊúüÁöÑÈôêÂà∂
    if (!this.store[ip] || now > this.store[ip].resetTime) {
      this.store[ip] = {
        count: 1,
        resetTime: now + this.TIME_WINDOW,
      };
      return true;
    }

    // Ê£ÄÊü•ÊòØÂê¶ËææÂà∞ÈôêÂà∂
    if (this.store[ip].count >= this.MAX_REQUESTS) {
      return false;
    }

    // ÈÄíÂ¢ûËÆ°Êï∞
    this.store[ip].count += 1;
    return true;
  },

  // Ëé∑ÂèñÂâ©‰ΩôÂèØÁî®Ê¨°Êï∞
  getRemainingRequests(ip) {
    const now = Date.now();

    if (!this.store[ip] || now > this.store[ip].resetTime) {
      return this.MAX_REQUESTS;
    }

    return Math.max(0, this.MAX_REQUESTS - this.store[ip].count);
  },

  // Ëé∑ÂèñÈáçÁΩÆÊó∂Èó¥
  getResetTime(ip) {
    const now = Date.now();

    if (!this.store[ip] || now > this.store[ip].resetTime) {
      return now + this.TIME_WINDOW;
    }

    return this.store[ip].resetTime;
  },

  // Ê∏ÖÁêÜËøáÊúüÁöÑËÆ∞ÂΩï (ÂÆöÊúüË∞ÉÁî®)
  cleanup() {
    const now = Date.now();
    for (const ip in this.store) {
      if (now > this.store[ip].resetTime) {
        delete this.store[ip];
      }
    }
  },
};

// ÊØèÂ∞èÊó∂Ê∏ÖÁêÜ‰∏ÄÊ¨°ËøáÊúüÁöÑÈôêÊµÅËÆ∞ÂΩï
setInterval(() => rateLimiter.cleanup(), 60 * 60 * 1000);

/** ÂÆâÂÖ®ÂìçÂ∫îÂ§¥ + CORS + Âü∫Á°ÄÂÆâÂÖ®Á≠ñÁï• */
app.use((req, res, next) => {
  // Âü∫Á°ÄÂÆâÂÖ®Â§¥
  res.setHeader('X-Content-Type-Options', 'nosniff');
  res.setHeader('Referrer-Policy', 'no-referrer');
  res.setHeader('X-Frame-Options', 'DENY');
  // HSTSÔºà‰ªÖÂú® HTTPS ÁîüÊïàÔºâ
  res.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains; preload');
  // ÊúÄÂ∞èÂèØË°å CSPÔºàÂÖÅËÆ∏ inline ‰ª•ÂÖºÂÆπÁé∞ÊúâÂâçÁ´ØÔºâ
  res.setHeader(
    'Content-Security-Policy',
    "default-src 'self'; base-uri 'self'; frame-ancestors 'none'; object-src 'none'; form-action 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content; img-src 'self' data: https:; style-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net https://cdnjs.cloudflare.com; script-src 'self' 'unsafe-inline'; connect-src 'self' https://api.bilibili.com; font-src 'self' data: https://cdn.jsdelivr.net https://cdnjs.cloudflare.com; manifest-src 'self'"
  );
  // CORS
  Object.entries(CORS_HEADERS).forEach(([k, v]) => res.setHeader(k, v));
  if (req.method === 'OPTIONS') return res.sendStatus(200);
  next();
});

// Êèê‰æõÈùôÊÄÅÊñá‰ª∂ÊúçÂä°
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
app.use(express.static(path.join(__dirname, 'public')));

// ËØ∑Ê±ÇID & Êó•Âøó‰∏≠Èó¥‰ª∂
app.use((req, res, next) => {
  const start = Date.now();
  const timestamp = new Date().toISOString();
  const ip = (req.headers['x-forwarded-for'] || req.socket.remoteAddress || '')
    .toString()
    .split(',')[0]
    .trim();
  const requestId =
    (req.headers['x-request-id'] && String(req.headers['x-request-id'])) ||
    `${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`;
  res.setHeader('X-Request-Id', requestId);
  // ËØ∑Ê±ÇÂºÄÂßãÊó•Âøó
  console.log(`[${timestamp}] üì• ${req.method} ${req.originalUrl} - IP: ${ip} - id=${requestId}`);
  // ÂìçÂ∫îÂÆåÊàêÂêéÁöÑÊó•Âøó
  res.on('finish', () => {
    const duration = Date.now() - start;
    const statusCode = res.statusCode;
    const statusEmoji = statusCode >= 400 ? '‚ùå' : '‚úÖ';
    console.log(
      `[${timestamp}] ${statusEmoji} ${req.method} ${req.originalUrl} - ${statusCode} - ${duration}ms - id=${requestId}`
    );
  });
  next();
});

// ËØªÂèñÁâàÊú¨‰ø°ÊÅØ
let VERSION = 'dev';
try {
  const pkg = JSON.parse(fs.readFileSync(path.join(__dirname, 'package.json'), 'utf-8'));
  VERSION = pkg.version || 'dev';
} catch {}

// ÈîôËØØÂ§ÑÁêÜ‰∏≠Èó¥‰ª∂
app.use((err, req, res, _next) => {
  console.error(`[${new Date().toISOString()}] ‚ùå ÊúçÂä°Âô®ÈîôËØØ:`, err);
  res.status(500).json({
    error: 'Internal Server Error',
    message: process.env.NODE_ENV === 'production' ? 'ÊúçÂä°Âô®ÂÜÖÈÉ®ÈîôËØØ' : err.message,
  });
});

// ÈôêÊµÅ‰∏≠Èó¥‰ª∂
const rateLimiterMiddleware = (req, res, next) => {
  // Ëé∑ÂèñÂÆ¢Êà∑Á´ØIP
  const ip =
    req.headers['x-forwarded-for'] ||
    req.connection.remoteAddress ||
    req.socket.remoteAddress ||
    (req.connection.socket ? req.connection.socket.remoteAddress : null);

  // Â∫îÁî®ÈôêÊµÅÔºàÊâÄÊúâËØ∑Ê±ÇÔºâ
  if (!rateLimiter.check(ip)) {
    const resetTime = new Date(rateLimiter.getResetTime(ip)).toISOString();

    // ËÆæÁΩÆÈÄüÁéáÈôêÂà∂ÂìçÂ∫îÂ§¥
    res.setHeader('X-RateLimit-Limit', rateLimiter.MAX_REQUESTS);
    res.setHeader('X-RateLimit-Remaining', 0);
    res.setHeader('X-RateLimit-Reset', resetTime);

    return res.status(429).json({
      error: 'ËØ∑Ê±ÇËøá‰∫éÈ¢ëÁπÅ',
      message: `APIË∞ÉÁî®Ê¨°Êï∞Â∑≤Ëææ‰∏äÈôêÔºåËØ∑Âú®${resetTime}ÂêéÂÜçËØï`,
      limit: rateLimiter.MAX_REQUESTS,
      window: '1Â∞èÊó∂',
      reset: resetTime,
    });
  }

  // ÂØπ‰∫éÂÖÅËÆ∏ÁöÑËØ∑Ê±ÇÔºåËÆæÁΩÆÂâ©‰ΩôÊ¨°Êï∞ÂìçÂ∫îÂ§¥
  res.setHeader('X-RateLimit-Limit', rateLimiter.MAX_REQUESTS);
  res.setHeader('X-RateLimit-Remaining', rateLimiter.getRemainingRequests(ip));
  res.setHeader('X-RateLimit-Reset', new Date(rateLimiter.getResetTime(ip)).toISOString());

  next();
};

// Ëé∑Âèñ BÁ´ôËøΩÁï™Êï∞ÊçÆ
app.get('/api/bangumi/:uid', rateLimiterMiddleware, async (req, res, next) => {
  const { uid } = req.params;

  if (!/^\d+$/.test(uid)) {
    console.warn(`[${new Date().toISOString()}] ‚ö†Ô∏è Êó†ÊïàÁöÑUIDÊ†ºÂºè: ${uid}`);
    return res.status(400).json({
      error: 'Invalid UID',
      message: 'UIDÂøÖÈ°ªÊòØÁ∫ØÊï∞Â≠ó',
    });
  }

  try {
    const data = await getBangumiData(uid);

    if (!data) {
      return res.status(500).json({
        error: 'Internal Server Error',
        message: 'Ëé∑ÂèñÊï∞ÊçÆÂ§±Ë¥•',
      });
    }

    if (data && typeof data.code === 'number' && data.code !== 0) {
      if (data.code === 53013) {
        return res.status(403).json(data);
      }
      return res.json(data);
    }

    const bodyJson = JSON.stringify(data);
    const etag = 'W/"' + crypto.createHash('sha1').update(bodyJson).digest('hex') + '"';
    const inm = req.headers['if-none-match'];
    if (inm && inm === etag) {
      return res.status(304).end();
    }
    res.setHeader('ETag', etag);
    res.setHeader('Cache-Control', 'public, max-age=300');
    res.type('application/json').send(bodyJson);
  } catch (err) {
    console.error(`[${new Date().toISOString()}] ‚ùå Â§ÑÁêÜËØ∑Ê±ÇÊó∂Âá∫Èîô:`, err);
    next(err);
  }
});

// ÂÅ•Â∫∑Ê£ÄÊü•Êé•Âè£
app.get('/status', (req, res) => {
  const uptime = process.uptime();
  const uptimeFormatted = formatUptime(uptime);
  const mem = Math.round(process.memoryUsage().rss / 1024 / 1024);
  res.send(
    `‚úÖ Bili-Calendar Service is running here.

ÊúçÂä°Áä∂ÊÄÅ:
- ÁâàÊú¨: ${VERSION}
- ËøêË°åÊó∂Èó¥: ${uptimeFormatted}
- ÂÜÖÂ≠ò‰ΩøÁî®: ${mem} MB
- ÁéØÂ¢É: ${process.env.NODE_ENV || 'development'}
- Á´ØÂè£: ${PORT}
`
  );
});

// Ê†πË∑ØÂæÑËøîÂõûÂâçÁ´ØÈ°µÈù¢
app.get('/', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

// Â§ÑÁêÜ UID Ë∑ØÁî±ÔºàÊòæÂºè .ics ‰∏éÁ∫Ø UIDÔºâ
const handleCalendar = async (req, res, next) => {
  const raw = req.params.uid;
  const uid = raw.replace('.ics', '');
  try {
    console.log(`[${new Date().toISOString()}] üîç Â§ÑÁêÜUID: ${uid}`);
    const data = await getBangumiData(uid);
    if (!data) {
      return res.status(500).send('Ëé∑ÂèñÊï∞ÊçÆÂ§±Ë¥•');
    }
    if (data.code !== 0) {
      if (data.code === 53013) {
        console.warn(`[${new Date().toISOString()}] ‚ö†Ô∏è Áî®Êà∑ÈöêÁßÅËÆæÁΩÆÈôêÂà∂: ${uid}`);
        return respondWithEmptyCalendar(res, uid, 'Áî®Êà∑ËÆæÁΩÆ‰∏∫ÈöêÁßÅ');
      }
      console.error(
        `[${new Date().toISOString()}] ‚ùå BÁ´ôAPIÈîôËØØ: ${data.message} (code: ${data.code})`
      );
      return res.status(500).send(`Bilibili API ÈîôËØØ: ${data.message} (code: ${data.code})`);
    }
    const bangumiList = data.data?.list || [];
    console.log(`[${new Date().toISOString()}] üìã Ëé∑ÂèñÂà∞Áï™ÂâßÂàóË°®Êï∞Èáè: ${bangumiList.length}`);
    if (bangumiList.length === 0) {
      console.warn(`[${new Date().toISOString()}] ‚ö†Ô∏è Êú™ÊâæÂà∞Ê≠£Âú®Êí≠Âá∫ÁöÑÁï™Ââß: ${uid}`);
      return respondWithEmptyCalendar(res, uid, 'Êú™ÊâæÂà∞Ê≠£Âú®Êí≠Âá∫ÁöÑÁï™Ââß');
    }
    console.log(`[${new Date().toISOString()}] üìÖ ÁîüÊàêÊó•ÂéÜÊñá‰ª∂`);
    const icsContent = generateICS(bangumiList, uid);
    return respondWithICS(res, icsContent, uid);
  } catch (err) {
    console.error(`[${new Date().toISOString()}] ‚ùå Â§ÑÁêÜËØ∑Ê±ÇÊó∂Âá∫Èîô:`, err);
    next(err);
  }
};
app.get('/:uid(\\d+)\\.ics', handleCalendar);
app.get('/:uid(\\d+)', handleCalendar);

// Â§ÑÁêÜ404ÈîôËØØ
app.use((req, res) => {
  console.warn(`[${new Date().toISOString()}] ‚ö†Ô∏è 404 Not Found: ${req.originalUrl}`);
  res.status(404).json({
    error: 'Not Found',
    message: `Ë∑ØÂæÑ ${req.originalUrl} ‰∏çÂ≠òÂú®`,
  });
});

// ÈîôËØØÂ§ÑÁêÜ‰∏≠Èó¥‰ª∂ÔºàÊîæÂú®ÊâÄÊúâË∑ØÁî±‰πãÂêéÔºâ
app.use((err, req, res, _next) => {
  console.error(`[${new Date().toISOString()}] ‚ùå ÊúçÂä°Âô®ÈîôËØØ:`, err);
  res.status(500).json({
    error: 'Internal Server Error',
    message: process.env.NODE_ENV === 'production' ? 'ÊúçÂä°Âô®ÂÜÖÈÉ®ÈîôËØØ' : err.message,
  });
});

/**
 * Fetches and filters the Bilibili bangumi (anime) follow list for a given user ID.
 *
 * Retrieves the user's followed bangumi list from the Bilibili API, handling HTTP and API errors.
 * Filters the list to include only currently airing series (not finished and with broadcast or update information).
 * Adds metadata about the filtering process to the returned object.
 *
 * @param {string|number} uid - The Bilibili user ID.
 * @returns {Promise<Object|null>} The filtered bangumi data object, or null if the request fails.
 */
// ÁßªÈô§ÔºögetBangumiData Êú¨Âú∞ÂÆûÁé∞ÔºåÁªü‰∏ÄÂ§çÁî® utils/bangumi.js

/**
 * Converts a duration in seconds to a human-readable string in Chinese, including days, hours, minutes, and seconds.
 * @param {number} seconds - The total number of seconds to format.
 * @return {string} The formatted uptime string in Chinese.
 */
function formatUptime(seconds) {
  const days = Math.floor(seconds / 86400);
  const hours = Math.floor((seconds % 86400) / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const secs = Math.floor(seconds % 60);

  const parts = [];
  if (days > 0) parts.push(`${days}Â§©`);
  if (hours > 0) parts.push(`${hours}Â∞èÊó∂`);
  if (minutes > 0) parts.push(`${minutes}ÂàÜÈíü`);
  if (secs > 0 || parts.length === 0) parts.push(`${secs}Áßí`);

  return parts.join(' ');
}

/* moved to utils/time.js: parseBroadcastTime */

export { app };
